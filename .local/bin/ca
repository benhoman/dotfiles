#!/usr/bin/env bash
set -euo pipefail

PROGNAME=$(basename "$0")
REPO=$(git rev-parse --show-toplevel)
REPO_NAME=$(basename "$REPO")
DOCKER_COMPOSE_FILE=$(find "$REPO" -type f -name docker-compose.yml -print -quit)

if [[ ! -f "$DOCKER_COMPOSE_FILE" ]]; then
  echo "Error: No docker-compose.yml found in $REPO" >&2
  exit 1
fi

_get_app_name() {
  if [[ $REPO_NAME == "brands" ]]; then
    echo "web"
  elif [[ $REPO_NAME == "reviews-api" ]]; then
    echo "api"
  else
    local app_name=$(docker compose -f "$DOCKER_COMPOSE_FILE" config --services | grep "django" | head -n1)
    if [[ -z "$app_name" ]]; then
      echo "Error: No django service found" >&2
      exit 1
    fi
    echo "$app_name"
  fi
}

_get_task_name() {
  docker compose -f "$DOCKER_COMPOSE_FILE" config --services | grep -E "celery-worker-|dramatiq-" | head -n1
}

_app_running() {
  docker compose ps --services --filter "status=running" | grep -q "$APP_NAME"
}

_exec_run() {
  if _app_running; then
    docker compose exec -e PYTHONWARNINGS=ignore "$APP_NAME" "$@"
  else
    docker compose run -e PYTHONWARNINGS=ignore --rm "$APP_NAME" "$@"
  fi
}

_exec_run_env() {
  if _app_running; then
    docker compose exec -e SSHKEY="$(cat ~/.ssh/id_rsa-ca)" -e KNOWN_HOSTS="$(ssh-keyscan github.com 2>/dev/null)" "$APP_NAME" "$@"
  else
    docker compose run -e SSHKEY="$(cat ~/.ssh/id_rsa-ca)" -e KNOWN_HOSTS="$(ssh-keyscan github.com 2>/dev/null)" --rm "$APP_NAME" "$@"
  fi
}

_pytest_convert() {
  # converts
  # app.misc.tests.test_tasks.SalesForceTest.test_send_to_salesforce
  # app/misc/tests/test_tasks.py::SalesForceTest::test_send_to_salesforce
  s="$1"
  words=(${s//./ })
  idx=""
  for i in "${!words[@]}"; do
    if [[ ${words[i]:0:1} == [[:upper:]] ]]; then
      idx="$i"
      break
    fi
  done
  if [[ -z "$idx" ]]; then
    file_path="${words[*]}"
    echo "${file_path// //}.py"
  else
    file_path="${words[*]:0:idx}"
    methods="${words[*]:idx}"
    echo "${file_path// //}.py::${methods// /::}"
  fi
}

APP_NAME=$(_get_app_name)
TASK_NAME=$(_get_task_name)

if [[ $TASK_NAME == *"celery"* ]]; then
  TLOG_FILE="celery-celery.log"
else
  TLOG_FILE="dramatiq.log"
fi

sub_help() {
  echo "Usage: $PROGNAME <subcommand> [options]\n"
  echo "Subcommands:"
  echo "  app             Print determined app name"
  echo "  bash            Open bash shell"
  echo "  build           Build docker image"
  echo "  manage          Run manage.py"
  echo "  migrate         Run migrations"
  echo "  makemigrations  Run makemigrations"
  echo "  pip-compile     Compile python dependencies"
  echo "  reup            Up and down"
  echo "  run             Run command in container"
  echo "  shell           Open django shell"
  echo "  showmigrations  Show migrations"
  echo "  superuser       Create Superuser"
  echo "  term            Open terminal"
  echo "  test            Run Tests"
  echo "  pytest          Run Tests with pytest"
  echo "  has_pytest      Project has pytest installed"
  echo "  logs            Show container logs"
  echo "  worktree            Worktree management (bootstrap, cleanup)"
  echo ""
}

sub_app() {
  echo "$APP_NAME"
}

sub_bash() {
  _exec_run bash
}

sub_build() {
  if [[ $REPO_NAME == "silverback" ]]; then
    echo "###################################"
    echo "# Building silverback base images #"
    echo "###################################"
    SSHKEY=$(cat ~/.ssh/id_rsa-ca) NPM_TOKEN=$(cat ~/.config/consumeraffairs/npmrc | grep ":_authToken=" | cut -d "=" -f2) KNOWN_HOSTS=$(ssh-keyscan github.com 2>/dev/null) DOCKER_BUILDKIT=1 docker compose build "$@" be-build-base fe-build-base
  fi
  echo "###################"
  echo "# Building images #"
  echo "###################"
  SSHKEY=$(cat ~/.ssh/id_rsa-ca) NPM_TOKEN=$(cat ~/.config/consumeraffairs/npmrc | grep ":_authToken=" | cut -d "=" -f2) KNOWN_HOSTS=$(ssh-keyscan github.com 2>/dev/null) DOCKER_BUILDKIT=1 docker compose build "$@"
}

sub_makemigrations() {
  _exec_run python manage.py makemigrations $@
}

sub_manage() {
  _exec_run python manage.py $@
}

sub_migrate() {
  _exec_run python manage.py migrate $@
}

sub_pip-compile() {
  _exec_run_env ./bin/pip-compile.sh
}

sub_compile-requirements() {
  _exec_run_env ./bin/compile-requirements.sh
}

sub_shell() {
  if rg -q "django-extensions" "$REPO"/requirements*; then
    SHELL_COMMAND="shell_plus"
  else
    SHELL_COMMAND="shell"
  fi
  sub_manage "$SHELL_COMMAND" "$@"
}

sub_showmigrations() {
  sub_manage showmigrations $@
}

sub_sqlmigrate() {
  sub_manage sqlmigrate $@
}

sub_superuser() {
  sub_manage createsuperuser $@
}

sub_reup() {
  docker compose down && docker compose up
}

sub_run() {
  _exec_run $@
}

sub_term() {
  _exec_run sh $@
}

sub_test() {
  if [[ $REPO_NAME =~ ^(silverback|match-api|dbus)$ ]]; then
    _exec_run pytest $@
  else
    sub_manage test --failfast $@
  fi
}

sub_pytest() {
  _exec_run pytest $@
}

sub_ruff() {
  ruff format .
  ruff check --fix .
}

sub_has_pytest() {
  rg -q "pytest" "$REPO"/requirements*
}

sub_logs() {
  docker compose logs -f "$APP_NAME" "$@"
}

sub_magictest() {
  if [[ $REPO_NAME =~ ^(silverback|match-api|reviews-api|reviews-moderation|dbus|consumeraffairs)$ ]]; then
    test_path=${@: -1}
    echo "running pytest"
    last_arg=$(_pytest_convert $test_path)
    echo $last_arg
    set -- "pytest" $last_arg
    if [[ $REPO_NAME == "reviews-moderation" ]]; then
      pytest $@
    else
      _exec_run $@
    fi
  else
    sub_test $@
  fi
}

_worktree_help() {
  echo "Usage: $PROGNAME worktree <subcommand> [options]"
  echo ""
  echo "Subcommands:"
  echo "  bootstrap    Bootstrap worktree with custom database directory"
  echo "  cleanup      Clean up worktree (stop containers, remove database, remove worktree)"
  echo ""
}

_worktree_check() {
  # Check if we're in a git worktree (not the main repository)
  local git_dir=$(git rev-parse --git-dir 2>/dev/null)
  local git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
  
  if [[ -z "$git_dir" ]]; then
    echo "Error: Not in a git repository" >&2
    echo "Worktree commands must be run from within a git worktree" >&2
    exit 1
  fi
  
  # Additional check: ensure we're not in a bare repository
  if git rev-parse --is-bare-repository >/dev/null 2>&1 && [[ "$(git rev-parse --is-bare-repository)" == "true" ]]; then
    echo "Error: Cannot run worktree commands in a bare repository" >&2
    exit 1
  fi
  
  # In a worktree, git-dir and git-common-dir are different
  # In the main repo, they are the same
  if [[ "$git_dir" == "$git_common_dir" ]]; then
    echo "Error: Worktree commands can only be run from within a git worktree, not the main repository" >&2
    echo "" >&2
    echo "Current location appears to be the main repository." >&2
    echo "To create a worktree: git worktree add ../TICKET-NUMBER origin/branch-name" >&2
    echo "Then cd into the worktree directory and run the command again." >&2
    exit 1
  fi
  
  # If we get here, we're in a worktree - show some helpful info
  local worktree_dir=$(basename "$REPO")
  echo "ℹ️  Running in worktree: $worktree_dir"
}

_worktree_extract_ticket_number() {
  local current_dir=$(basename "$REPO")
  local ticket_number=""
  
  # Try to extract ticket number (e.g., PDW-1234 from various formats)
  if [[ $current_dir =~ ([A-Z]+-[0-9]+) ]]; then
    ticket_number="${BASH_REMATCH[1]}"
    echo "$ticket_number"
  else
    return 1
  fi
}

_worktree_bootstrap() {
  # Ensure we're in a worktree
  _worktree_check
  
  # Extract ticket number from current directory name
  local ticket_number
  ticket_number=$(_worktree_extract_ticket_number)
  
  if [[ -z "$ticket_number" ]]; then
    echo "Warning: Could not detect ticket number from directory name '$(basename "$REPO")'"
    read -p "Enter ticket number (e.g., PDW-1234): " ticket_number
    if [[ -z "$ticket_number" ]]; then
      echo "Error: Ticket number is required for database directory naming"
      exit 1
    fi
  else
    echo "Detected ticket number: $ticket_number"
  fi
  
  # Handle pgdata operations only if the pgdata directory exists
  local pgdata_parent_dir="$REPO/../pgdata"
  local override_created=false
  
  if [[ -d "$pgdata_parent_dir" ]]; then
    echo "Found pgdata directory, setting up database isolation..."
    
    # Determine source and target database directories
    local source_db_dir="$pgdata_parent_dir/qa"
    local target_db_dir="$pgdata_parent_dir/$ticket_number"
    
    # Check if source database directory exists
    if [[ ! -d "$source_db_dir" ]]; then
      echo "Warning: Source database directory '$source_db_dir' does not exist"
      echo "Creating empty database directory for '$ticket_number'"
      mkdir -p "$target_db_dir"
    else
      echo "Copying database from qa to $ticket_number..."
      
      # Check if target already exists
      if [[ -d "$target_db_dir" ]]; then
        echo "Warning: Target database directory '$target_db_dir' already exists"
        read -p "Overwrite existing database? [y/N]: " confirm
        if [[ ! $confirm =~ ^[Yy]$ ]]; then
          echo "Skipping database copy"
        else
          rm -rf "$target_db_dir"
        fi
      fi
      
      # Check if source is a btrfs subvolume
      if command -v btrfs >/dev/null 2>&1 && sudo btrfs subvolume show "$source_db_dir" >/dev/null 2>&1; then
        echo "Source is a btrfs subvolume, creating read-write snapshot..."
        sudo btrfs subvolume snapshot "$source_db_dir" "$target_db_dir"
        echo "Created btrfs snapshot: $target_db_dir"
      else
        # Regular directory copy
        if [[ ! -d "$target_db_dir" ]]; then
          echo "Copying database directory..."
          sudo cp -r "$source_db_dir" "$target_db_dir"
          echo "Copied database to: $target_db_dir"
        fi
      fi
    fi
    
    # Create docker-compose.override.yml for database volume override
    echo "Creating docker-compose.override.yml for database isolation..."
    cat > "$REPO/docker-compose.override.yml" << EOF
volumes:
  pgdata:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ../pgdata/$ticket_number
EOF
    override_created=true
  else
    echo "No pgdata directory found, skipping database isolation setup"
  fi
  
  # Fix image naming issues for services that reference built images
  echo "Checking for image naming issues in docker-compose.yml..."
  local worktree_name=$(basename "$REPO")
  local services_with_image_fixes=()
  
  # Get the full docker-compose config once
  local compose_config=$(docker compose -f "$DOCKER_COMPOSE_FILE" config 2>&1 | grep -v "^WARN\[")
  
  # Get all services that have build contexts (these create images)
  local buildable_services=()
  while read -r service; do
    if echo "$compose_config" | grep -A 20 "^  $service:" | grep -q "^    build:"; then
      buildable_services+=("$service")
      echo "  Buildable service found: $service"
    fi
  done < <(docker compose -f "$DOCKER_COMPOSE_FILE" config --services 2>&1 | grep -v "^WARN\[")
  
  # Check each service for image references that need fixing
  while read -r service; do
    local image_line=$(echo "$compose_config" | grep -A 20 "^  $service:" | grep "^    image:" | head -1)
    
    if [[ -n "$image_line" ]]; then
      local image_name=$(echo "$image_line" | sed 's/^    image: //' | tr -d '"' | tr -d "'")
      echo "  Service $service has image: $image_name"
      
      # Check if image follows pattern: {prefix}_{service_name}
      if [[ "$image_name" =~ ^([^_]+)_(.+)$ ]]; then
        local current_prefix="${BASH_REMATCH[1]}"
        local image_suffix="${BASH_REMATCH[2]}"
        
        # Check if this image suffix matches any buildable service (with dash-to-underscore conversion)
        for buildable_service in "${buildable_services[@]}"; do
          local buildable_with_underscore="${buildable_service//-/_}"
          if [[ "$image_suffix" == "$buildable_service" || "$image_suffix" == "$buildable_with_underscore" ]]; then
            local new_image_name="${worktree_name}_${image_suffix}"
            services_with_image_fixes+=("$service:$new_image_name")
            echo "  ✅ Found image fix needed: $service ($image_name -> $new_image_name)"
            break
          fi
        done
      fi
    fi
  done < <(docker compose -f "$DOCKER_COMPOSE_FILE" config --services)
  
  # Create or update docker-compose.override.yml with image fixes
  if [[ ${#services_with_image_fixes[@]} -gt 0 ]]; then
    echo "Creating/updating docker-compose.override.yml with image fixes..."
    
    local override_file="$REPO/docker-compose.override.yml"
    local temp_override=""
    
    # Check if override file exists and has services section not created by us
    local override_has_manual_changes=false
    if [[ -f "$override_file" && "$override_created" == false ]]; then
      if grep -q "^services:" "$override_file" 2>/dev/null; then
        echo "⚠️  Existing docker-compose.override.yml found with services section"
        read -p "This may overwrite manual customizations. Continue? [y/N]: " confirm
        if [[ ! $confirm =~ ^[Yy]$ ]]; then
          echo "Skipping image fixes to preserve existing override file"
          echo "💡 You can manually add these image overrides:"
          for service_fix in "${services_with_image_fixes[@]}"; do
            local service_name="${service_fix%%:*}"
            local new_image="${service_fix##*:}"
            echo "   $service_name -> image: $new_image"
          done
          return
        fi
        override_has_manual_changes=true
      fi
    fi
    
    # Start building the override content
    if [[ "$override_created" == true ]]; then
      # Read our previously created override file and append services section
      temp_override=$(cat "$override_file")
      temp_override="$temp_override"$'\n'"services:"
    elif [[ "$override_has_manual_changes" == true ]]; then
      # Preserve existing content and append our services
      temp_override=$(cat "$override_file")
      if ! grep -q "^services:" "$override_file"; then
        temp_override="$temp_override"$'\n'"services:"
      fi
    else
      temp_override="services:"
    fi
    
    # Add each service that needs image fixing
    for service_fix in "${services_with_image_fixes[@]}"; do
      local service_name="${service_fix%%:*}"
      local new_image="${service_fix##*:}"
      temp_override="$temp_override"$'\n'"  $service_name:"$'\n'"    image: $new_image"
    done
    
    # Write the complete override file
    echo "$temp_override" > "$override_file"
    echo "✅ Updated docker-compose.override.yml with ${#services_with_image_fixes[@]} image fixes"
    override_created=true
  else
    echo "❌ No image naming issues detected"
  fi
  
  # Copy configuration files from main repository to worktree
  echo "Copying configuration files..."
  local git_common_dir=$(git rev-parse --git-common-dir)
  local main_repo_dir=$(dirname "$git_common_dir")
  local files_copied=()
  
  # Check for copy list file first
  # File format: source_path[:destination_path] (one per line)
  # If destination_path is omitted, source_path is used as destination
  # Example ca-copy-list content:
  #   # Configuration files
  #   .env:.env          # explicit source:destination
  #   .env               # destination defaults to source (.env)
  #   config/settings.json:config/settings.json  # explicit
  #   config/dev.json    # destination defaults to source
  #   scripts/init.sh:bin/init.sh  # different destination
  local copy_list_file="$main_repo_dir/ca-copy-list"
  if [[ -f "$copy_list_file" ]]; then
    echo "  Found copy list file: ca-copy-list"
    while IFS=':' read -r source_path dest_path; do
      # Skip empty lines and comments
      [[ -z "$source_path" || "$source_path" =~ ^[[:space:]]*# ]] && continue
      
      # Trim whitespace
      source_path=$(echo "$source_path" | xargs)
      dest_path=$(echo "$dest_path" | xargs)
      
      # If no destination path provided, use source path
      [[ -z "$dest_path" ]] && dest_path="$source_path"
      
      local source_file="$main_repo_dir/$source_path"
      local target_file="$REPO/$dest_path"
      
      # Create target directory if it doesn't exist
      local target_dir=$(dirname "$target_file")
      [[ ! -d "$target_dir" ]] && mkdir -p "$target_dir"
      
      if [[ -f "$source_file" ]]; then
        if [[ -f "$target_file" ]]; then
          echo "  $dest_path already exists in worktree, skipping"
        else
          cp "$source_file" "$target_file"
          files_copied+=("$dest_path")
          echo "  ✅ Copied $source_path -> $dest_path"
        fi
      else
        echo "  ⚠️  $source_path not found in main repository"
      fi
    done < "$copy_list_file"
  else
    # Fallback to hardcoded list
    local files_to_copy=(".env")
    
    for file in "${files_to_copy[@]}"; do
      local source_file="$main_repo_dir/$file"
      local target_file="$REPO/$file"
      
      if [[ -f "$source_file" ]]; then
        if [[ -f "$target_file" ]]; then
          echo "  $file already exists in worktree, skipping"
        else
          cp "$source_file" "$target_file"
          files_copied+=("$file")
          echo "  ✅ Copied $file"
        fi
      else
        echo "  ⚠️  $file not found in main repository"
      fi
    done
  fi
  
  echo "✅ Bootstrap complete!"
  if [[ "$override_created" == true ]]; then
    echo "   Database directory: ../pgdata/$ticket_number"
    echo "   Override file: docker-compose.override.yml"
  fi
  if [[ ${#files_copied[@]} -gt 0 ]]; then
    echo "   Configuration files: ${files_copied[*]}"
  fi
  echo ""
  echo "To start using the isolated database:"
  echo "   docker-compose down && docker-compose up"
}

_worktree_cleanup() {
  # Ensure we're in a worktree
  _worktree_check
  
  # Extract ticket number from current directory name
  local ticket_number
  ticket_number=$(_worktree_extract_ticket_number)
  
  if [[ -z "$ticket_number" ]]; then
    echo "Warning: Could not detect ticket number from directory name '$(basename "$REPO")'"
    read -p "Enter ticket number for database cleanup (e.g., PDW-1234): " ticket_number
    if [[ -z "$ticket_number" ]]; then
      echo "Error: Ticket number is required for database cleanup"
      exit 1
    fi
  else
    echo "Detected ticket number: $ticket_number"
  fi
  
  local pgdata_parent_dir="$REPO/../pgdata"
  local db_dir="$pgdata_parent_dir/$ticket_number"
  local worktree_dir="$REPO"
  local parent_dir=$(dirname "$REPO")
  
  echo "🧹 Worktree cleanup for $ticket_number"
  echo "   Worktree: $worktree_dir"
  if [[ -d "$pgdata_parent_dir" ]]; then
    echo "   Database: $db_dir"
  fi
  echo ""
  
  # Confirm cleanup
  read -p "This will stop containers, remove database, and remove worktree. Continue? [y/N]: " confirm
  if [[ ! $confirm =~ ^[Yy]$ ]]; then
    echo "Cleanup cancelled"
    exit 0
  fi
  
  # Step 1: Stop and remove containers with volumes
  echo "🔻 Stopping Docker containers and removing volumes..."
  if [[ -f "$REPO/docker-compose.yml" ]] || [[ -f "$REPO/docker-compose.override.yml" ]]; then
    docker compose down --volumes 2>&1 | grep -v "^WARN\[" || echo "No containers to stop"
  fi
  
  # Step 2: Remove database directory (only if pgdata parent exists)
  if [[ -d "$pgdata_parent_dir" ]]; then
    if [[ -d "$db_dir" ]]; then
      echo "🗑️  Removing database directory: $db_dir"
      
      # Check if it's a btrfs subvolume
      if command -v btrfs >/dev/null 2>&1 && sudo btrfs subvolume show "$db_dir" >/dev/null 2>&1; then
        echo "Deleting btrfs subvolume..."
        sudo btrfs subvolume delete "$db_dir"
      else
        sudo rm -rf "$db_dir"
      fi
      echo "Database directory removed"
    else
      echo "Database directory not found: $db_dir"
    fi
  else
    echo "No pgdata directory found, skipping database cleanup"
  fi
  
  # Step 3: Remove worktree
  echo "🗂️  Removing git worktree..."
  cd "$parent_dir"
  if git worktree remove "$worktree_dir" --force 2>/dev/null; then
    echo "Git worktree removed successfully"
  else
    echo "⚠️  Failed to remove git worktree automatically"
    echo "   Please manually run: git worktree remove $worktree_dir --force"
    echo "   Or from the parent directory: git worktree prune"
  fi
  
  echo "✅ Cleanup complete!"
  echo "   Worktree '$ticket_number' has been removed"
}

sub_worktree() {
  local worktree_subcommand=${1:-""}
  
  case $worktree_subcommand in
    "bootstrap")
      shift
      _worktree_bootstrap "$@"
      ;;
    "cleanup")
      shift
      _worktree_cleanup "$@"
      ;;
    "" | "-h" | "--help")
      _worktree_help
      ;;
    *)
      echo "Error: '$worktree_subcommand' is not a known worktree subcommand." >&2
      _worktree_help
      exit 1
      ;;
  esac
}

subcommand=$1
case $subcommand in
"" | "-h" | "--help")
  sub_help
  ;;
*)
  shift
  sub_${subcommand} $@
  if [ $? = 127 ]; then
    echo "Error: '$subcommand' is not a known subcommand." >&2
    echo "       Run '$PROGNAME --help' for a list of known subcommands." >&2
    exit 1
  fi
  ;;
esac
