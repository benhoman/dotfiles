#!/usr/bin/env bash
set -euo pipefail

PROGNAME=$(basename "$0")

# Cached functions for stateless operation
_get_repo() {
  if [[ -z "${_CACHED_REPO:-}" ]]; then
    _CACHED_REPO=$(git rev-parse --show-toplevel 2>/dev/null)
    if [[ -z "$_CACHED_REPO" ]]; then
      echo "Error: Not in a git repository" >&2
      exit 1
    fi
  fi
  echo "$_CACHED_REPO"
}

_get_repo_name() {
  if [[ -z "${_CACHED_REPO_NAME:-}" ]]; then
    _CACHED_REPO_NAME=$(basename "$(_get_repo)")
  fi
  echo "$_CACHED_REPO_NAME"
}

_get_docker_compose_file() {
  if [[ -z "${_CACHED_DOCKER_COMPOSE_FILE:-}" ]]; then
    local repo=$(_get_repo)
    _CACHED_DOCKER_COMPOSE_FILE=$(find "$repo" -type f -name docker-compose.yml -print -quit)
    if [[ ! -f "$_CACHED_DOCKER_COMPOSE_FILE" ]]; then
      echo "Error: No docker-compose.yml found in $repo" >&2
      exit 1
    fi
  fi
  echo "$_CACHED_DOCKER_COMPOSE_FILE"
}

# Helper function to run docker compose with the right file
_docker_compose() {
  local compose_file=$(_get_docker_compose_file)
  docker compose -f "$compose_file" "$@"
}

_get_app_name() {
  if [[ -z "${_CACHED_APP_NAME:-}" ]]; then
    local repo_name=$(_get_repo_name)
    if [[ $repo_name == "brands" ]]; then
      _CACHED_APP_NAME="web"
    elif [[ $repo_name == "reviews-api" ]]; then
      _CACHED_APP_NAME="api"
    else
      _CACHED_APP_NAME=$(_docker_compose config --services | grep "django" | head -n1)
      if [[ -z "$_CACHED_APP_NAME" ]]; then
        echo "Error: No django service found" >&2
        exit 1
      fi
    fi
  fi
  echo "$_CACHED_APP_NAME"
}

_get_task_name() {
  if [[ -z "${_CACHED_TASK_NAME:-}" ]]; then
    _CACHED_TASK_NAME=$(_docker_compose config --services | grep -E "celery-worker-|dramatiq-" | head -n1 || true)
  fi
  echo "$_CACHED_TASK_NAME"
}

_app_running() {
  local app_name=$(_get_app_name)
  _docker_compose ps --services --filter "status=running" | grep -q "$app_name"
}

_exec_run() {
  local app_name=$(_get_app_name)
  if _app_running; then
    _docker_compose exec -e PYTHONWARNINGS=ignore "$app_name" "$@"
  else
    _docker_compose run -e PYTHONWARNINGS=ignore --rm "$app_name" "$@"
  fi
}

_exec_run_env() {
  local app_name=$(_get_app_name)
  if _app_running; then
    _docker_compose exec -e SSHKEY="$(cat ~/.ssh/id_rsa-ca)" -e KNOWN_HOSTS="$(ssh-keyscan github.com 2>/dev/null)" "$app_name" "$@"
  else
    _docker_compose run -e SSHKEY="$(cat ~/.ssh/id_rsa-ca)" -e KNOWN_HOSTS="$(ssh-keyscan github.com 2>/dev/null)" --rm "$app_name" "$@"
  fi
}

_pytest_convert() {
  # converts
  # app.misc.tests.test_tasks.SalesForceTest.test_send_to_salesforce
  # app/misc/tests/test_tasks.py::SalesForceTest::test_send_to_salesforce
  s="$1"
  words=(${s//./ })
  idx=""
  for i in "${!words[@]}"; do
    if [[ ${words[i]:0:1} == [[:upper:]] ]]; then
      idx="$i"
      break
    fi
  done
  if [[ -z "$idx" ]]; then
    file_path="${words[*]}"
    echo "${file_path// //}.py"
  else
    file_path="${words[*]:0:idx}"
    methods="${words[*]:idx}"
    echo "${file_path// //}.py::${methods// /::}"
  fi
}

_get_tlog_file() {
  if [[ -z "${_CACHED_TLOG_FILE:-}" ]]; then
    local task_name=$(_get_task_name)
    if [[ "$task_name" == *"celery"* ]]; then
      _CACHED_TLOG_FILE="celery-celery.log"
    else
      _CACHED_TLOG_FILE="dramatiq.log"
    fi
  fi
  echo "$_CACHED_TLOG_FILE"
}

sub_help() {
  echo "Usage: $PROGNAME <subcommand> [options]\n"
  echo "Subcommands:"
  echo "  app             Print determined app name"
  echo "  bash            Open bash shell"
  echo "  build           Build docker image"
  echo "  manage          Run manage.py"
  echo "  migrate         Run migrations"
  echo "  makemigrations  Run makemigrations"
  echo "  pip-compile     Compile python dependencies"
  echo "  reup            Up and down"
  echo "  run             Run command in container"
  echo "  shell           Open django shell"
  echo "  showmigrations  Show migrations"
  echo "  superuser       Create Superuser"
  echo "  term            Open terminal"
  echo "  test            Run Tests"
  echo "  pytest          Run Tests with pytest"
  echo "  has_pytest      Project has pytest installed"
  echo "  logs            Show container logs"
  echo "  worktree            Worktree management (init, bootstrap, cleanup)"
  echo ""
}

sub_app() {
  echo "$(_get_app_name)"
}

sub_repo_name() {
  echo "Repo Name"
  echo "$(_get_repo_name)"
}

sub_bash() {
  _exec_run bash
}

sub_build() {
  local repo_name=$(_get_repo_name)
  if [[ $repo_name == "silverback" ]]; then
    echo "###################################"
    echo "# Building silverback base images #"
    echo "###################################"
    SSHKEY=$(cat ~/.ssh/id_rsa-ca) NPM_TOKEN=$(cat ~/.config/consumeraffairs/npmrc | grep ":_authToken=" | cut -d "=" -f2) KNOWN_HOSTS=$(ssh-keyscan github.com 2>/dev/null) DOCKER_BUILDKIT=1 _docker_compose build "$@" be-build-base fe-build-base
  fi
  echo "###################"
  echo "# Building images #"
  echo "###################"
  SSHKEY=$(cat ~/.ssh/id_rsa-ca) NPM_TOKEN=$(cat ~/.config/consumeraffairs/npmrc | grep ":_authToken=" | cut -d "=" -f2) KNOWN_HOSTS=$(ssh-keyscan github.com 2>/dev/null) DOCKER_BUILDKIT=1 _docker_compose build "$@"
}

sub_makemigrations() {
  _exec_run python manage.py makemigrations $@
}

sub_manage() {
  _exec_run python manage.py $@
}

sub_migrate() {
  _exec_run python manage.py migrate $@
}

sub_pip-compile() {
  _exec_run_env ./bin/pip-compile.sh
}

sub_compile-requirements() {
  _exec_run_env ./bin/compile-requirements.sh
}

sub_shell() {
  local repo=$(_get_repo)
  if rg -q "django-extensions" "$repo"/requirements*; then
    SHELL_COMMAND="shell_plus"
  else
    SHELL_COMMAND="shell"
  fi
  sub_manage "$SHELL_COMMAND" "$@"
}

sub_showmigrations() {
  sub_manage showmigrations $@
}

sub_sqlmigrate() {
  sub_manage sqlmigrate $@
}

sub_superuser() {
  sub_manage createsuperuser $@
}

sub_reup() {
  _docker_compose down && _docker_compose up
}

sub_run() {
  _exec_run $@
}

sub_term() {
  _exec_run sh $@
}

sub_test() {
  local repo_name=$(_get_repo_name)
  if [[ $repo_name =~ ^(silverback|match-api|dbus)$ ]]; then
    _exec_run pytest $@
  else
    sub_manage test --failfast $@
  fi
}

sub_pytest() {
  _exec_run pytest $@
}

sub_ruff() {
  ruff format .
  ruff check --fix .
}

sub_has_pytest() {
  local repo=$(_get_repo)
  rg -q "pytest" "$repo"/requirements*
}

sub_logs() {
  local app_name=$(_get_app_name)
  _docker_compose logs -f "$app_name" "$@"
}

sub_magictest() {
  local repo_name=$(_get_repo_name)
  if [[ $repo_name =~ ^(silverback|match-api|reviews-api|reviews-moderation|dbus|consumeraffairs)$ ]]; then
    test_path=${@: -1}
    echo "running pytest"
    last_arg=$(_pytest_convert $test_path)
    echo $last_arg
    set -- "pytest" $last_arg
    if [[ $repo_name == "reviews-moderation" ]]; then
      pytest $@
    else
      _exec_run $@
    fi
  else
    sub_test $@
  fi
}

_worktree_help() {
  echo "Usage: $PROGNAME worktree <subcommand> [options]"
  echo ""
  echo "Subcommands:"
  echo "  init         Create new worktree from upstream branch (default: qa)"
  echo "  bootstrap    Bootstrap worktree with custom database directory"
  echo "  cleanup      Clean up worktree (stop containers, remove database, remove worktree)"
  echo ""
}

_worktree_check() {
  # Check if we're in a git worktree (not the main repository)
  local git_dir=$(git rev-parse --git-dir 2>/dev/null)
  local git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)

  if [[ -z "$git_dir" ]]; then
    echo "Error: Not in a git repository" >&2
    echo "Worktree commands must be run from within a git worktree" >&2
    exit 1
  fi

  # Additional check: ensure we're not in a bare repository
  if git rev-parse --is-bare-repository >/dev/null 2>&1 && [[ "$(git rev-parse --is-bare-repository)" == "true" ]]; then
    echo "Error: Cannot run worktree commands in a bare repository" >&2
    exit 1
  fi

  # In a worktree, git-dir and git-common-dir are different
  # In the main repo, they are the same
  if [[ "$git_dir" == "$git_common_dir" ]]; then
    echo "Error: Worktree commands can only be run from within a git worktree, not the main repository" >&2
    echo "" >&2
    echo "Current location appears to be the main repository." >&2
    echo "To create a worktree: git worktree add ../TICKET-NUMBER origin/branch-name" >&2
    echo "Then cd into the worktree directory and run the command again." >&2
    exit 1
  fi

  # If we get here, we're in a worktree - show some helpful info
  local repo=$(_get_repo)
  local worktree_dir=$(basename "$repo")
  echo "ℹ️  Running in worktree: $worktree_dir"
}

_worktree_extract_ticket_number() {
  local repo=$(_get_repo)
  local current_dir=$(basename "$repo")
  local ticket_number=""

  # Try to extract ticket number (e.g., PDW-1234 from various formats)
  if [[ $current_dir =~ ([A-Z]+-[0-9]+) ]]; then
    ticket_number="${BASH_REMATCH[1]}"
    echo "$ticket_number"
  else
    return 1
  fi
}

_worktree_bootstrap() {
  # Ensure we're in a worktree
  _worktree_check

  # Extract ticket number from current directory name
  local ticket_number
  ticket_number=$(_worktree_extract_ticket_number)

  if [[ -z "$ticket_number" ]]; then
    local repo=$(_get_repo)
    echo "Warning: Could not detect ticket number from directory name '$(basename "$repo")'"
    read -p "Enter ticket number (e.g., PDW-1234): " ticket_number
    if [[ -z "$ticket_number" ]]; then
      echo "Error: Ticket number is required for database directory naming"
      exit 1
    fi
  else
    echo "Detected ticket number: $ticket_number"
  fi

  # Handle pgdata operations only if the pgdata directory exists
  local repo=$(_get_repo)
  local pgdata_parent_dir="$repo/../pgdata"
  local override_created=false

  if [[ -d "$pgdata_parent_dir" ]]; then
    echo "Found pgdata directory, setting up database isolation..."

    # Determine source and target database directories
    local source_db_dir="$pgdata_parent_dir/qa"
    local target_db_dir="$pgdata_parent_dir/$ticket_number"

    # Check if source database directory exists
    if [[ ! -d "$source_db_dir" ]]; then
      echo "Warning: Source database directory '$source_db_dir' does not exist"
      echo "Creating empty database directory for '$ticket_number'"
      mkdir -p "$target_db_dir"
    else
      echo "Copying database from qa to $ticket_number..."

      # Check if target already exists
      if [[ -d "$target_db_dir" ]]; then
        echo "Warning: Target database directory '$target_db_dir' already exists"
        read -p "Overwrite existing database? [y/N]: " confirm
        if [[ ! $confirm =~ ^[Yy]$ ]]; then
          echo "Skipping database copy"
        else
          rm -rf "$target_db_dir"
        fi
      fi

      # Check if source is a btrfs subvolume
      if command -v btrfs >/dev/null 2>&1 && sudo btrfs subvolume show "$source_db_dir" >/dev/null 2>&1; then
        echo "Source is a btrfs subvolume, creating read-write snapshot..."
        sudo btrfs subvolume snapshot "$source_db_dir" "$target_db_dir"
        echo "Created btrfs snapshot: $target_db_dir"
      else
        # Regular directory copy
        if [[ ! -d "$target_db_dir" ]]; then
          echo "Copying database directory..."
          sudo cp -r "$source_db_dir" "$target_db_dir"
          echo "Copied database to: $target_db_dir"
        fi
      fi
    fi

    # Create docker-compose.override.yml for database volume override
    echo "Creating docker-compose.override.yml for database isolation..."
    cat >"$repo/docker-compose.override.yml" <<EOF
volumes:
  pgdata:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ../pgdata/$ticket_number
EOF
    override_created=true
  else
    echo "No pgdata directory found, skipping database isolation setup"
  fi

  # Fix image naming issues for services that reference built images
  echo "Checking for image naming issues in docker-compose.yml..."
  local worktree_name=$(basename "$repo")
  local services_with_image_fixes=()

  # Get the full docker-compose config once
  local compose_config=$(_docker_compose config 2>&1 | grep -v "^WARN\[")

  # Get all services that have build contexts (these create images)
  local buildable_services=()
  while read -r service; do
    if echo "$compose_config" | grep -A 20 "^  $service:" | grep -q "^    build:"; then
      buildable_services+=("$service")
      echo "  Buildable service found: $service"
    fi
  done < <(_docker_compose config --services 2>&1 | grep -v "^WARN\[")

  # Check each service for image references that need fixing
  while read -r service; do
    local image_line=$(echo "$compose_config" | grep -A 20 "^  $service:" | grep "^    image:" | head -1)

    if [[ -n "$image_line" ]]; then
      local image_name=$(echo "$image_line" | sed 's/^    image: //' | tr -d '"' | tr -d "'")
      echo "  Service $service has image: $image_name"

      # Check if image follows pattern: {prefix}_{service_name}
      if [[ "$image_name" =~ ^([^_]+)_(.+)$ ]]; then
        local current_prefix="${BASH_REMATCH[1]}"
        local image_suffix="${BASH_REMATCH[2]}"

        # Check if this image suffix matches any buildable service (with dash-to-underscore conversion)
        for buildable_service in "${buildable_services[@]}"; do
          local buildable_with_underscore="${buildable_service//-/_}"
          if [[ "$image_suffix" == "$buildable_service" || "$image_suffix" == "$buildable_with_underscore" ]]; then
            local new_image_name="${worktree_name}_${image_suffix}"
            services_with_image_fixes+=("$service:$new_image_name")
            echo "  ✅ Found image fix needed: $service ($image_name -> $new_image_name)"
            break
          fi
        done
      fi
    fi
  done < <(_docker_compose config --services)

  # Create or update docker-compose.override.yml with image fixes
  if [[ ${#services_with_image_fixes[@]} -gt 0 ]]; then
    echo "Creating/updating docker-compose.override.yml with image fixes..."

    local override_file="$repo/docker-compose.override.yml"
    local temp_override=""

    # Check if override file exists and has services section not created by us
    local override_has_manual_changes=false
    if [[ -f "$override_file" && "$override_created" == false ]]; then
      if grep -q "^services:" "$override_file" 2>/dev/null; then
        echo "⚠️  Existing docker-compose.override.yml found with services section"
        read -p "This may overwrite manual customizations. Continue? [y/N]: " confirm
        if [[ ! $confirm =~ ^[Yy]$ ]]; then
          echo "Skipping image fixes to preserve existing override file"
          echo "💡 You can manually add these image overrides:"
          for service_fix in "${services_with_image_fixes[@]}"; do
            local service_name="${service_fix%%:*}"
            local new_image="${service_fix##*:}"
            echo "   $service_name -> image: $new_image"
          done
          return
        fi
        override_has_manual_changes=true
      fi
    fi

    # Start building the override content
    if [[ "$override_created" == true ]]; then
      # Read our previously created override file and append services section
      temp_override=$(cat "$override_file")
      temp_override="$temp_override"$'\n'"services:"
    elif [[ "$override_has_manual_changes" == true ]]; then
      # Preserve existing content and append our services
      temp_override=$(cat "$override_file")
      if ! grep -q "^services:" "$override_file"; then
        temp_override="$temp_override"$'\n'"services:"
      fi
    else
      temp_override="services:"
    fi

    # Add each service that needs image fixing
    for service_fix in "${services_with_image_fixes[@]}"; do
      local service_name="${service_fix%%:*}"
      local new_image="${service_fix##*:}"
      temp_override="$temp_override"$'\n'"  $service_name:"$'\n'"    image: $new_image"
    done

    # Write the complete override file
    echo "$temp_override" >"$override_file"
    echo "✅ Updated docker-compose.override.yml with ${#services_with_image_fixes[@]} image fixes"
    override_created=true
  else
    echo "❌ No image naming issues detected"
  fi

  # Copy configuration files from main repository to worktree
  echo "Copying configuration files..."
  local git_common_dir=$(git rev-parse --git-common-dir)
  local main_repo_dir=$(dirname "$git_common_dir")
  local files_copied=()

  # Check for copy list file first
  # File format: source_path[:destination_path] (one per line)
  # If destination_path is omitted, source_path is used as destination
  # Example ca-copy-list content:
  #   # Configuration files
  #   .env:.env          # explicit source:destination
  #   .env               # destination defaults to source (.env)
  #   config/settings.json:config/settings.json  # explicit
  #   config/dev.json    # destination defaults to source
  #   scripts/init.sh:bin/init.sh  # different destination
  local copy_list_file="$main_repo_dir/ca-copy-list"
  if [[ -f "$copy_list_file" ]]; then
    echo "  Found copy list file: ca-copy-list"
    while IFS=':' read -r source_path dest_path; do
      # Skip empty lines and comments
      [[ -z "$source_path" || "$source_path" =~ ^[[:space:]]*# ]] && continue

      # Trim whitespace
      source_path=$(echo "$source_path" | xargs)
      dest_path=$(echo "$dest_path" | xargs)

      # If no destination path provided, use source path
      [[ -z "$dest_path" ]] && dest_path="$source_path"

      local source_file="$main_repo_dir/$source_path"
      local target_file="$repo/$dest_path"

      # Create target directory if it doesn't exist
      local target_dir=$(dirname "$target_file")
      [[ ! -d "$target_dir" ]] && mkdir -p "$target_dir"

      if [[ -f "$source_file" ]]; then
        if [[ -f "$target_file" ]]; then
          echo "  $dest_path already exists in worktree, skipping"
        else
          cp "$source_file" "$target_file"
          files_copied+=("$dest_path")
          echo "  ✅ Copied $source_path -> $dest_path"
        fi
      else
        echo "  ⚠️  $source_path not found in main repository"
      fi
    done <"$copy_list_file"
  else
    # Fallback to hardcoded list
    local files_to_copy=(".env")

    for file in "${files_to_copy[@]}"; do
      local source_file="$main_repo_dir/$file"
      local target_file="$repo/$file"

      if [[ -f "$source_file" ]]; then
        if [[ -f "$target_file" ]]; then
          echo "  $file already exists in worktree, skipping"
        else
          cp "$source_file" "$target_file"
          files_copied+=("$file")
          echo "  ✅ Copied $file"
        fi
      else
        echo "  ⚠️  $file not found in main repository"
      fi
    done
  fi

  echo "✅ Bootstrap complete!"
  if [[ "$override_created" == true ]]; then
    echo "   Database directory: ../pgdata/$ticket_number"
    echo "   Override file: docker-compose.override.yml"
  fi
  if [[ ${#files_copied[@]} -gt 0 ]]; then
    echo "   Configuration files: ${files_copied[*]}"
  fi
  echo ""
  echo "To start using the isolated database:"
  echo "   docker-compose down && docker-compose up"
}

_worktree_cleanup() {
  # Ensure we're in a worktree
  _worktree_check

  # Extract ticket number from current directory name
  local ticket_number
  ticket_number=$(_worktree_extract_ticket_number)

  if [[ -z "$ticket_number" ]]; then
    local repo=$(_get_repo)
    echo "Warning: Could not detect ticket number from directory name '$(basename "$repo")'"
    read -p "Enter ticket number for database cleanup (e.g., PDW-1234): " ticket_number
    if [[ -z "$ticket_number" ]]; then
      echo "Error: Ticket number is required for database cleanup"
      exit 1
    fi
  else
    echo "Detected ticket number: $ticket_number"
  fi

  local repo=$(_get_repo)
  local pgdata_parent_dir="$repo/../pgdata"
  local db_dir="$pgdata_parent_dir/$ticket_number"
  local worktree_dir="$repo"
  local parent_dir=$(dirname "$repo")

  echo "🧹 Worktree cleanup for $ticket_number"
  echo "   Worktree: $worktree_dir"
  if [[ -d "$pgdata_parent_dir" ]]; then
    echo "   Database: $db_dir"
  fi
  echo ""

  # Confirm cleanup
  read -p "This will stop containers, remove database, and remove worktree. Continue? [y/N]: " confirm
  if [[ ! $confirm =~ ^[Yy]$ ]]; then
    echo "Cleanup cancelled"
    exit 0
  fi

  # Step 1: Stop and remove containers with volumes
  echo "🔻 Stopping Docker containers and removing volumes..."
  if [[ -f "$repo/docker-compose.yml" ]] || [[ -f "$repo/docker-compose.override.yml" ]]; then
    _docker_compose down --volumes --rmi all 2>&1 | grep -v "^WARN\[" || echo "No containers to stop"
  fi

  # Step 2: Remove database directory (only if pgdata parent exists)
  if [[ -d "$pgdata_parent_dir" ]]; then
    if [[ -d "$db_dir" ]]; then
      echo "🗑️  Removing database directory: $db_dir"

      # Check if it's a btrfs subvolume
      if command -v btrfs >/dev/null 2>&1 && sudo btrfs subvolume show "$db_dir" >/dev/null 2>&1; then
        echo "Deleting btrfs subvolume..."
        sudo btrfs subvolume delete "$db_dir"
      else
        sudo rm -rf "$db_dir"
      fi
      echo "Database directory removed"
    else
      echo "Database directory not found: $db_dir"
    fi
  else
    echo "No pgdata directory found, skipping database cleanup"
  fi

  # Step 3: Remove worktree
  echo "🗂️  Removing git worktree..."
  cd "$parent_dir"
  if git worktree remove "$worktree_dir" --force 2>/dev/null; then
    echo "Git worktree removed successfully"
  else
    echo "⚠️  Failed to remove git worktree automatically"
    echo "   Please manually run: git worktree remove $worktree_dir --force"
    echo "   Or from the parent directory: git worktree prune"
  fi

  echo "✅ Cleanup complete!"
  echo "   Worktree '$ticket_number' has been removed"
}

_worktree_init() {
  # Parse command line arguments
  local base_branch="qa"
  local worktree_name=""
  
  while [[ $# -gt 0 ]]; do
    case $1 in
      -b|--branch)
        base_branch="$2"
        shift 2
        ;;
      -h|--help)
        echo "Usage: ca worktree init [-b|--branch BRANCH_NAME] [WORKTREE_NAME]"
        echo ""
        echo "Options:"
        echo "  -b, --branch BRANCH_NAME  Base branch to create worktree from (default: qa)"
        echo "  -h, --help               Show this help message"
        echo ""
        echo "Arguments:"
        echo "  WORKTREE_NAME            Name for the new worktree directory"
        return 0
        ;;
      -*)
        echo "Error: Unknown option $1" >&2
        return 1
        ;;
      *)
        worktree_name="$1"
        break
        ;;
    esac
  done

  # Check that we're in the main repository (not already in a worktree)
  local git_dir=$(git rev-parse --git-dir 2>/dev/null)
  local git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)

  if [[ -z "$git_dir" ]]; then
    echo "Error: Not in a git repository" >&2
    return 1
  fi

  # In a worktree, git-dir and git-common-dir are different
  if [[ "$git_dir" != "$git_common_dir" ]]; then
    echo "Error: Already in a worktree. Run 'ca worktree init' from the main repository" >&2
    return 1
  fi

  # Prompt for worktree name if not provided
  if [[ -z "$worktree_name" ]]; then
    read -p "Enter worktree name (e.g., PDW-1234-feature-description): " worktree_name
    if [[ -z "$worktree_name" ]]; then
      echo "Error: Worktree name is required"
      return 1
    fi
  fi

  local worktree_path="../$worktree_name"

  echo "Creating worktree '$worktree_name' from '$base_branch'..."

  # Fetch latest changes
  echo "Fetching latest changes..."
  git fetch origin

  # Check if base branch exists on remote
  if ! git show-ref --verify --quiet "refs/remotes/origin/$base_branch"; then
    echo "Error: Branch '$base_branch' not found on remote"
    echo "Available remote branches:"
    git branch -r --format='%(refname:short)' | sed 's/origin\///' | head -10
    return 1
  fi

  # Create worktree
  echo "Creating worktree at: $worktree_path"
  if ! git worktree add --track -B "$worktree_name" "$worktree_path" "origin/$base_branch"; then
    echo "Error: Failed to create worktree"
    return 1
  fi

  echo "✅ Worktree created successfully!"
  echo ""
  echo "Next steps:"
  echo "  1. cd $worktree_path"
  echo "  2. ca worktree bootstrap  # Set up database isolation and config files"
  echo "  3. docker compose up     # Start the isolated environment"
  echo ""
  echo "To clean up later: cd $worktree_path && ca worktree cleanup"
}

sub_worktree() {
  local worktree_subcommand=${1:-""}

  case $worktree_subcommand in
  "init")
    shift
    _worktree_init "$@"
    ;;
  "bootstrap")
    shift
    _worktree_bootstrap "$@"
    ;;
  "cleanup")
    shift
    _worktree_cleanup "$@"
    ;;
  "" | "-h" | "--help")
    _worktree_help
    ;;
  *)
    echo "Error: '$worktree_subcommand' is not a known worktree subcommand." >&2
    _worktree_help
    exit 1
    ;;
  esac
}

subcommand=$1
case $subcommand in
"" | "-h" | "--help")
  sub_help
  ;;
*)
  shift
  sub_${subcommand} $@
  if [ $? = 127 ]; then
    echo "Error: '$subcommand' is not a known subcommand." >&2
    echo "       Run '$PROGNAME --help' for a list of known subcommands." >&2
    exit 1
  fi
  ;;
esac
